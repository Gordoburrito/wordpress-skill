#!/usr/bin/env bash
set -euo pipefail

SCRIPT_DIR="$(cd -- "$(dirname -- "${BASH_SOURCE[0]}")" && pwd)"
SKILL_ROOT="$(cd -- "${SCRIPT_DIR}/.." && pwd)"
TARGET_CONFIG="${SKILL_ROOT}/config/target-main.sh"
WORKSPACE_ROOT="$(cd -- "${SKILL_ROOT}/.." && pwd)"
TARGET_ENV_FILE="${WORKSPACE_ROOT}/.env"
LEGACY_ENV_FILE="${SKILL_ROOT}/.env"

fail() {
  echo "ERROR: $*" >&2
  exit 1
}

require_command() {
  local cmd="$1"
  command -v "${cmd}" >/dev/null 2>&1 || fail "Required command not found: ${cmd}"
}

require_json_object() {
  local file="$1"
  local label="$2"
  if ! jq -e 'type == "object"' "${file}" >/dev/null 2>&1; then
    fail "${label} is not a valid JSON object: ${file}"
  fi
}

json_pretty_write() {
  local src="$1"
  local dest="$2"
  jq '.' "${src}" > "${dest}"
}

load_target_config() {
  if [[ -f "${TARGET_ENV_FILE}" ]]; then
    # shellcheck disable=SC1090
    source "${TARGET_ENV_FILE}"
  elif [[ -f "${LEGACY_ENV_FILE}" ]]; then
    # Backward-compatible fallback for older setup.
    # shellcheck disable=SC1090
    source "${LEGACY_ENV_FILE}"
  fi

  [[ -f "${TARGET_CONFIG}" ]] || fail "Missing target config: ${TARGET_CONFIG}"
  # shellcheck disable=SC1090
  source "${TARGET_CONFIG}"

  : "${TARGET_BASE_URL:?TARGET_BASE_URL must be set in config/target-main.sh}"

  TARGET_API_USER="${TARGET_API_USER:-${WP_API_USER:-}}"
  TARGET_API_APP_PASSWORD="${TARGET_API_APP_PASSWORD:-${WP_API_APP_PASSWORD:-}}"
  : "${TARGET_API_USER:?TARGET_API_USER (or WP_API_USER env) must be set in config/target-main.sh}"
  : "${TARGET_API_APP_PASSWORD:?TARGET_API_APP_PASSWORD (or WP_API_APP_PASSWORD env) must be set in config/target-main.sh}"

  TARGET_BASE_URL="${TARGET_BASE_URL%/}"
  TARGET_API_PULL_PATH="${TARGET_API_PULL_PATH:-/wp-json/acf-schema/v1/pull}"
  TARGET_API_PUSH_PATH="${TARGET_API_PUSH_PATH:-/wp-json/acf-schema/v1/push}"
  TARGET_API_PUSH_ROUTE="${TARGET_API_PUSH_ROUTE:-/acf-schema/v1/push}"
  TARGET_CURL_TIMEOUT="${TARGET_CURL_TIMEOUT:-30}"
  TARGET_API_HMAC_SECRET="${TARGET_API_HMAC_SECRET:-${ACF_SCHEMA_API_HMAC_SECRET:-}}"

  PULL_URL="${TARGET_BASE_URL}${TARGET_API_PULL_PATH}"
  PUSH_URL="${TARGET_BASE_URL}${TARGET_API_PUSH_PATH}"
  API_AUTH="${TARGET_API_USER}:${TARGET_API_APP_PASSWORD}"
}

render_api_error() {
  local status="$1"
  local body_file="$2"

  if jq -e '.' "${body_file}" >/dev/null 2>&1; then
    local code
    local message
    code="$(jq -r '.code // empty' "${body_file}")"
    message="$(jq -r '.message // empty' "${body_file}")"

    if [[ -n "${code}" || -n "${message}" ]]; then
      echo "HTTP ${status} from API." >&2
      [[ -n "${code}" ]] && echo "  code: ${code}" >&2
      [[ -n "${message}" ]] && echo "  message: ${message}" >&2
    else
      echo "HTTP ${status} from API with JSON error response." >&2
    fi

    if jq -e '.data.errors | type == "array"' "${body_file}" >/dev/null 2>&1; then
      echo "  details:" >&2
      jq -r '.data.errors[] | "    - " + .' "${body_file}" >&2
    fi

    return
  fi

  echo "HTTP ${status} from API (non-JSON response)." >&2
  sed 's/^/  /' "${body_file}" >&2
}

api_post_json() {
  local url="$1"
  local payload_file="$2"
  local response_file="$3"
  shift 3

  local http_code
  http_code="$(curl -sS --show-error \
    --connect-timeout "${TARGET_CURL_TIMEOUT}" \
    --max-time "${TARGET_CURL_TIMEOUT}" \
    --user "${API_AUTH}" \
    -H "Content-Type: application/json" \
    "$@" \
    -X POST \
    --data-binary "@${payload_file}" \
    -o "${response_file}" \
    -w "%{http_code}" \
    "${url}")"

  [[ "${http_code}" =~ ^[0-9]{3}$ ]] || fail "Unexpected HTTP status from API call: ${http_code}"

  if (( http_code >= 400 )); then
    render_api_error "${http_code}" "${response_file}"
    return 1
  fi

  require_json_object "${response_file}" "API response"
}

build_push_signature_headers() {
  local payload_file="$1"
  [[ -n "${TARGET_API_HMAC_SECRET}" ]] || fail "TARGET_API_HMAC_SECRET (or ACF_SCHEMA_API_HMAC_SECRET) is required for signed push."

  local timestamp
  local nonce
  local body_hash
  local canonical
  local signature

  timestamp="$(date +%s)"
  nonce="$(openssl rand -hex 16)"
  body_hash="$(openssl dgst -sha256 "${payload_file}" | awk '{print $NF}')"
  canonical="$(printf 'POST\n%s\n%s\n%s\n%s' "${TARGET_API_PUSH_ROUTE}" "${timestamp}" "${nonce}" "${body_hash}")"
  signature="$(printf '%s' "${canonical}" | openssl dgst -sha256 -hmac "${TARGET_API_HMAC_SECRET}" | awk '{print $NF}')"

  PUSH_SIGNATURE_HEADERS=(
    -H "X-ACF-Schema-Timestamp: ${timestamp}"
    -H "X-ACF-Schema-Nonce: ${nonce}"
    -H "X-ACF-Schema-Signature: ${signature}"
  )
}
